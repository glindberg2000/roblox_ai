local KillBotService = {}

local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")

-- Helper function: uses raycasting to determine if the bot has a direct line-of-sight
local function checkSight(botPrimary, targetPrimary)
	local origin = botPrimary.Position
	local direction = (targetPrimary.Position - origin).Unit * 1000
	local ray = Ray.new(origin, direction)
	
	-- Ignore the bot's own model
	local hit = workspace:FindPartOnRayWithIgnoreList(ray, {botPrimary.Parent})
	if hit and hit:IsDescendantOf(targetPrimary.Parent) then
		-- Optionally check vertical alignment (tolerance of 2 studs)
		if math.abs(hit.Position.Y - origin.Y) < 2 then
			return true
		end
	end
	return false
end

-- Activate kill bot behavior for a specific NPC and target.
-- npc: A table containing at least the npc.model (a Model instance).
-- target: The character (Model) that the NPC should target.
--
-- Returns an optional deactivation function that, when called, will stop the bot.
function KillBotService:ActivateKillBot(npc, target)
	if not npc or not target then
		warn("KillBotService:ActivateKillBot requires valid npc and target")
		return false
	end

	-- Get the NPC's model, primary part and humanoid:
	local botModel = npc.model
	if not botModel then
		warn("KillBotService: NPC is missing a model")
		return false
	end

	local botPrimary = botModel:FindFirstChild("HumanoidRootPart")
	if not botPrimary then
		warn("KillBotService: NPC model does not have a HumanoidRootPart")
		return false
	end
	-- Ensure the server controls the physics:
	botPrimary:SetNetworkOwner(nil)

	local botHumanoid = botModel:FindFirstChildOfClass("Humanoid")
	if not botHumanoid then
		warn("KillBotService: NPC model does not have a Humanoid")
		return false
	end

	-- Verify the target has a HumanoidRootPart.
	local targetPrimary = target:FindFirstChild("HumanoidRootPart")
	if not targetPrimary then
		warn("KillBotService: Target is missing a HumanoidRootPart")
		return false
	end

	-- Parameters for pathfinding.
	local agentParams = {
		AgentRadius = 0.25,
		AgentCanJump = true,
		AgentHeight = 5.0,
		WaypointSpacing = math.huge,
	}
	local path = PathfindingService:CreatePath(agentParams)

	-- Flag to control the kill-bot loop.
	local isActive = true

	-- Main loop: repeatedly update the NPC's movement toward the target.
	task.spawn(function()
		while isActive and npc.model and target and target.Parent do
			local hasSight = checkSight(botPrimary, targetPrimary)
			if hasSight then
				-- Direct line-of-sight: move directly to target.
				botHumanoid:MoveTo(targetPrimary.Position)
			else
				-- No line-of-sight: compute a path.
				path:ComputeAsync(botPrimary.Position, targetPrimary.Position)
				if path.Status == Enum.PathStatus.Success then
					-- Follow each waypoint generated by the pathfinder.
					for _, waypoint in ipairs(path:GetWaypoints()) do
						if waypoint.Action == Enum.PathWaypointAction.Jump then
							botHumanoid.Jump = true
						end
						botHumanoid:MoveTo(waypoint.Position)
						-- Wait until the NPC reaches the waypoint (or times out).
						local success = botHumanoid.MoveToFinished:Wait()
						if not success then
							break
						end
					end
				end
			end

			-- Optional: if the NPC is moving too slowly, make it jump.
			if botPrimary.Velocity.Magnitude <= 4 and not botHumanoid.Jump then
				botHumanoid.Jump = true
			end

			task.wait(0.5)
		end
	end)

	-- Return a deactivation function so the caller can stop the kill bot behavior.
	return function()
		isActive = false
	end
end

return KillBotService 